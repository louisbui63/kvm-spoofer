diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index a394514264..e860da4ab4 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -94,7 +94,7 @@ static QTAILQ_HEAD(, type8_instance) type8 = QTAILQ_HEAD_INITIALIZER(type8);
 struct type9_instance {
     const char *slot_designation, *pcidev;
     uint8_t slot_type, slot_data_bus_width, current_usage, slot_length,
-            slot_characteristics1, slot_characteristics2;
+        slot_characteristics1, slot_characteristics2;
     uint16_t slot_id;
     QTAILQ_ENTRY(type9_instance) next;
 };
@@ -110,21 +110,32 @@ static struct {
     uint16_t speed;
 } type17;
 
-static QEnumLookup type41_kind_lookup = {
-    .array = (const char *const[]) {
-        "other",
-        "unknown",
-        "video",
-        "scsi",
-        "ethernet",
-        "tokenring",
-        "sound",
-        "pata",
-        "sata",
-        "sas",
-    },
-    .size = 10
-};
+static struct {
+    const char *description;
+} type27;
+
+static struct {
+    const char *description;
+} type28;
+
+static struct {
+    const char *description;
+} type29;
+
+static QEnumLookup type41_kind_lookup = {.array =
+                                             (const char *const[]){
+                                                 "other",
+                                                 "unknown",
+                                                 "video",
+                                                 "scsi",
+                                                 "ethernet",
+                                                 "tokenring",
+                                                 "sound",
+                                                 "pata",
+                                                 "sata",
+                                                 "sas",
+                                             },
+                                         .size = 10};
 struct type41_instance {
     const char *designation, *pcidev;
     uint8_t instance, kind;
@@ -135,14 +146,11 @@ static QTAILQ_HEAD(, type41_instance) type41 = QTAILQ_HEAD_INITIALIZER(type41);
 static QemuOptsList qemu_smbios_opts = {
     .name = "smbios",
     .head = QTAILQ_HEAD_INITIALIZER(qemu_smbios_opts.head),
-    .desc = {
-        /*
-         * no elements => accept any params
-         * validation will happen later
-         */
-        { /* end of list */ }
-    }
-};
+    .desc = {/*
+              * no elements => accept any params
+              * validation will happen later
+              */
+             {/* end of list */}}};
 
 static const QemuOptDesc qemu_smbios_file_opts[] = {
     {
@@ -150,185 +158,212 @@ static const QemuOptDesc qemu_smbios_file_opts[] = {
         .type = QEMU_OPT_STRING,
         .help = "binary file containing an SMBIOS element",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type0_opts[] = {
     {
         .name = "type",
         .type = QEMU_OPT_NUMBER,
         .help = "SMBIOS element type",
-    },{
+    },
+    {
         .name = "vendor",
         .type = QEMU_OPT_STRING,
         .help = "vendor name",
-    },{
+    },
+    {
         .name = "version",
         .type = QEMU_OPT_STRING,
         .help = "version number",
-    },{
+    },
+    {
         .name = "date",
         .type = QEMU_OPT_STRING,
         .help = "release date",
-    },{
+    },
+    {
         .name = "release",
         .type = QEMU_OPT_STRING,
         .help = "revision number",
-    },{
+    },
+    {
         .name = "uefi",
         .type = QEMU_OPT_BOOL,
         .help = "uefi support",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type1_opts[] = {
     {
         .name = "type",
         .type = QEMU_OPT_NUMBER,
         .help = "SMBIOS element type",
-    },{
+    },
+    {
         .name = "manufacturer",
         .type = QEMU_OPT_STRING,
         .help = "manufacturer name",
-    },{
+    },
+    {
         .name = "product",
         .type = QEMU_OPT_STRING,
         .help = "product name",
-    },{
+    },
+    {
         .name = "version",
         .type = QEMU_OPT_STRING,
         .help = "version number",
-    },{
+    },
+    {
         .name = "serial",
         .type = QEMU_OPT_STRING,
         .help = "serial number",
-    },{
+    },
+    {
         .name = "uuid",
         .type = QEMU_OPT_STRING,
         .help = "UUID",
-    },{
+    },
+    {
         .name = "sku",
         .type = QEMU_OPT_STRING,
         .help = "SKU number",
-    },{
+    },
+    {
         .name = "family",
         .type = QEMU_OPT_STRING,
         .help = "family name",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type2_opts[] = {
     {
         .name = "type",
         .type = QEMU_OPT_NUMBER,
         .help = "SMBIOS element type",
-    },{
+    },
+    {
         .name = "manufacturer",
         .type = QEMU_OPT_STRING,
         .help = "manufacturer name",
-    },{
+    },
+    {
         .name = "product",
         .type = QEMU_OPT_STRING,
         .help = "product name",
-    },{
+    },
+    {
         .name = "version",
         .type = QEMU_OPT_STRING,
         .help = "version number",
-    },{
+    },
+    {
         .name = "serial",
         .type = QEMU_OPT_STRING,
         .help = "serial number",
-    },{
+    },
+    {
         .name = "asset",
         .type = QEMU_OPT_STRING,
         .help = "asset tag number",
-    },{
+    },
+    {
         .name = "location",
         .type = QEMU_OPT_STRING,
         .help = "location in chassis",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type3_opts[] = {
     {
         .name = "type",
         .type = QEMU_OPT_NUMBER,
         .help = "SMBIOS element type",
-    },{
+    },
+    {
         .name = "manufacturer",
         .type = QEMU_OPT_STRING,
         .help = "manufacturer name",
-    },{
+    },
+    {
         .name = "version",
         .type = QEMU_OPT_STRING,
         .help = "version number",
-    },{
+    },
+    {
         .name = "serial",
         .type = QEMU_OPT_STRING,
         .help = "serial number",
-    },{
+    },
+    {
         .name = "asset",
         .type = QEMU_OPT_STRING,
         .help = "asset tag number",
-    },{
+    },
+    {
         .name = "sku",
         .type = QEMU_OPT_STRING,
         .help = "SKU number",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type4_opts[] = {
     {
         .name = "type",
         .type = QEMU_OPT_NUMBER,
         .help = "SMBIOS element type",
-    },{
+    },
+    {
         .name = "sock_pfx",
         .type = QEMU_OPT_STRING,
         .help = "socket designation string prefix",
-    },{
+    },
+    {
         .name = "manufacturer",
         .type = QEMU_OPT_STRING,
         .help = "manufacturer name",
-    },{
+    },
+    {
         .name = "version",
         .type = QEMU_OPT_STRING,
         .help = "version number",
-    },{
+    },
+    {
         .name = "max-speed",
         .type = QEMU_OPT_NUMBER,
         .help = "max speed in MHz",
-    },{
+    },
+    {
         .name = "current-speed",
         .type = QEMU_OPT_NUMBER,
         .help = "speed at system boot in MHz",
-    },{
+    },
+    {
         .name = "serial",
         .type = QEMU_OPT_STRING,
         .help = "serial number",
-    },{
+    },
+    {
         .name = "asset",
         .type = QEMU_OPT_STRING,
         .help = "asset tag number",
-    },{
+    },
+    {
         .name = "part",
         .type = QEMU_OPT_STRING,
         .help = "part number",
-    }, {
+    },
+    {
         .name = "processor-family",
         .type = QEMU_OPT_NUMBER,
         .help = "processor family",
-    }, {
+    },
+    {
         .name = "processor-id",
         .type = QEMU_OPT_NUMBER,
         .help = "processor id",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type8_opts[] = {
     {
@@ -356,8 +391,7 @@ static const QemuOptDesc qemu_smbios_type8_opts[] = {
         .type = QEMU_OPT_NUMBER,
         .help = "port type",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type9_opts[] = {
     {
@@ -405,12 +439,9 @@ static const QemuOptDesc qemu_smbios_type9_opts[] = {
         .type = QEMU_OPT_NUMBER,
         .help = "slot characteristics2, see the spec",
     },
-    {
-        .name = "pci_device",
-        .type = QEMU_OPT_STRING,
-        .help = "PCI device, if provided."
-    }
-};
+    {.name = "pci_device",
+     .type = QEMU_OPT_STRING,
+     .help = "PCI device, if provided."}};
 
 static const QemuOptDesc qemu_smbios_type11_opts[] = {
     {
@@ -428,76 +459,81 @@ static const QemuOptDesc qemu_smbios_type11_opts[] = {
         .type = QEMU_OPT_STRING,
         .help = "OEM string data from file",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type17_opts[] = {
     {
         .name = "type",
         .type = QEMU_OPT_NUMBER,
         .help = "SMBIOS element type",
-    },{
+    },
+    {
         .name = "loc_pfx",
         .type = QEMU_OPT_STRING,
         .help = "device locator string prefix",
-    },{
+    },
+    {
         .name = "bank",
         .type = QEMU_OPT_STRING,
         .help = "bank locator string",
-    },{
+    },
+    {
         .name = "manufacturer",
         .type = QEMU_OPT_STRING,
         .help = "manufacturer name",
-    },{
+    },
+    {
         .name = "serial",
         .type = QEMU_OPT_STRING,
         .help = "serial number",
-    },{
+    },
+    {
         .name = "asset",
         .type = QEMU_OPT_STRING,
         .help = "asset tag number",
-    },{
+    },
+    {
         .name = "part",
         .type = QEMU_OPT_STRING,
         .help = "part number",
-    },{
+    },
+    {
         .name = "speed",
         .type = QEMU_OPT_NUMBER,
         .help = "maximum capable speed",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
 static const QemuOptDesc qemu_smbios_type41_opts[] = {
     {
         .name = "type",
         .type = QEMU_OPT_NUMBER,
         .help = "SMBIOS element type",
-    },{
+    },
+    {
         .name = "designation",
         .type = QEMU_OPT_STRING,
         .help = "reference designation string",
-    },{
+    },
+    {
         .name = "kind",
         .type = QEMU_OPT_STRING,
         .help = "device type",
         .def_value_str = "other",
-    },{
+    },
+    {
         .name = "instance",
         .type = QEMU_OPT_NUMBER,
         .help = "device type instance",
-    },{
+    },
+    {
         .name = "pcidev",
         .type = QEMU_OPT_STRING,
         .help = "PCI device",
     },
-    { /* end of list */ }
-};
+    {/* end of list */}};
 
-static void smbios_register_config(void)
-{
-    qemu_add_opts(&qemu_smbios_opts);
-}
+static void smbios_register_config(void) { qemu_add_opts(&qemu_smbios_opts); }
 
 opts_init(smbios_register_config);
 
@@ -508,8 +544,7 @@ opts_init(smbios_register_config);
  */
 #define SMBIOS_21_MAX_TABLES_LEN 0xffff
 
-static bool smbios_check_type4_count(uint32_t expected_t4_count, Error **errp)
-{
+static bool smbios_check_type4_count(uint32_t expected_t4_count, Error **errp) {
     if (smbios_type4_count && smbios_type4_count != expected_t4_count) {
         error_setg(errp, "Expected %d SMBIOS Type 4 tables, got %d instead",
                    expected_t4_count, smbios_type4_count);
@@ -518,8 +553,7 @@ static bool smbios_check_type4_count(uint32_t expected_t4_count, Error **errp)
     return true;
 }
 
-bool smbios_validate_table(SmbiosEntryPointType ep_type, Error **errp)
-{
+bool smbios_validate_table(SmbiosEntryPointType ep_type, Error **errp) {
     if (ep_type == SMBIOS_ENTRY_POINT_TYPE_32 &&
         smbios_tables_len > SMBIOS_21_MAX_TABLES_LEN) {
         error_setg(errp, "SMBIOS 2.1 table length %zu exceeds %d",
@@ -529,8 +563,7 @@ bool smbios_validate_table(SmbiosEntryPointType ep_type, Error **errp)
     return true;
 }
 
-bool smbios_skip_table(uint8_t type, bool required_table)
-{
+bool smbios_skip_table(uint8_t type, bool required_table) {
     if (test_bit(type, smbios_have_binfile_bitmap)) {
         return true; /* user provided their own binary blob(s) */
     }
@@ -554,12 +587,14 @@ bool smbios_skip_table(uint8_t type, bool required_table)
 #define T16_BASE 0x1000
 #define T17_BASE 0x1100
 #define T19_BASE 0x1300
+#define T27_BASE 0x1B00
+#define T28_BASE 0x1C00
+#define T29_BASE 0x1D00
 #define T32_BASE 0x2000
 #define T41_BASE 0x2900
 #define T127_BASE 0x7F00
 
-static void smbios_build_type_0_table(void)
-{
+static void smbios_build_type_0_table(void) {
     SMBIOS_BUILD_TABLE_PRE(0, T0_BASE, false); /* optional, leave up to BIOS */
 
     SMBIOS_TABLE_SET_STR(0, vendor_str, smbios_type0.vendor);
@@ -596,16 +631,14 @@ static void smbios_build_type_0_table(void)
 /* Encode UUID from the big endian encoding described on RFC4122 to the wire
  * format specified by SMBIOS version 2.6.
  */
-static void smbios_encode_uuid(struct smbios_uuid *uuid, QemuUUID *in)
-{
+static void smbios_encode_uuid(struct smbios_uuid *uuid, QemuUUID *in) {
     memcpy(uuid, in, 16);
     uuid->time_low = bswap32(uuid->time_low);
     uuid->time_mid = bswap16(uuid->time_mid);
     uuid->time_hi_and_version = bswap16(uuid->time_hi_and_version);
 }
 
-static void smbios_build_type_1_table(void)
-{
+static void smbios_build_type_1_table(void) {
     SMBIOS_BUILD_TABLE_PRE(1, T1_BASE, true); /* required */
 
     SMBIOS_TABLE_SET_STR(1, manufacturer_str, smbios_type1.manufacturer);
@@ -624,8 +657,7 @@ static void smbios_build_type_1_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_2_table(void)
-{
+static void smbios_build_type_2_table(void) {
     SMBIOS_BUILD_TABLE_PRE(2, T2_BASE, false); /* optional */
 
     SMBIOS_TABLE_SET_STR(2, manufacturer_str, type2.manufacturer);
@@ -636,14 +668,13 @@ static void smbios_build_type_2_table(void)
     t->feature_flags = 0x01; /* Motherboard */
     SMBIOS_TABLE_SET_STR(2, location_str, type2.location);
     t->chassis_handle = cpu_to_le16(0x300); /* Type 3 (System enclosure) */
-    t->board_type = 0x0A; /* Motherboard */
+    t->board_type = 0x0A;                   /* Motherboard */
     t->contained_element_count = 0;
 
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_3_table(void)
-{
+static void smbios_build_type_3_table(void) {
     SMBIOS_BUILD_TABLE_PRE(3, T3_BASE, true); /* required */
 
     SMBIOS_TABLE_SET_STR(3, manufacturer_str, type3.manufacturer);
@@ -651,10 +682,10 @@ static void smbios_build_type_3_table(void)
     SMBIOS_TABLE_SET_STR(3, version_str, type3.version);
     SMBIOS_TABLE_SET_STR(3, serial_number_str, type3.serial);
     SMBIOS_TABLE_SET_STR(3, asset_tag_number_str, type3.asset);
-    t->boot_up_state = 0x03; /* Safe */
+    t->boot_up_state = 0x03;      /* Safe */
     t->power_supply_state = 0x03; /* Safe */
-    t->thermal_state = 0x03; /* Safe */
-    t->security_status = 0x02; /* Unknown */
+    t->thermal_state = 0x03;      /* Safe */
+    t->security_status = 0x02;    /* Unknown */
     t->oem_defined = cpu_to_le32(0);
     t->height = 0;
     t->number_of_power_cords = 0;
@@ -667,8 +698,7 @@ static void smbios_build_type_3_table(void)
 
 static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
                                       SmbiosEntryPointType ep_type,
-                                      Error **errp)
-{
+                                      Error **errp) {
     char sock_str[128];
     size_t tbl_len = SMBIOS_TYPE_4_LEN_V28;
     unsigned threads_per_socket;
@@ -678,12 +708,12 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
         tbl_len = SMBIOS_TYPE_4_LEN_V30;
     }
 
-    SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance,
-                                true, tbl_len); /* required */
+    SMBIOS_BUILD_TABLE_PRE_SIZE(4, T4_BASE + instance, true,
+                                tbl_len); /* required */
 
     snprintf(sock_str, sizeof(sock_str), "%s%2x", type4.sock_pfx, instance);
     SMBIOS_TABLE_SET_STR(4, socket_designation_str, sock_str);
-    t->processor_type = 0x03; /* CPU */
+    t->processor_type = 0x03;   /* CPU */
     t->processor_family = 0xfe; /* use Processor Family 2 field */
     SMBIOS_TABLE_SET_STR(4, processor_manufacturer_str, type4.manufacturer);
     if (type4.processor_id == 0) {
@@ -698,7 +728,7 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     t->external_clock = cpu_to_le16(0); /* Unknown */
     t->max_speed = cpu_to_le16(type4.max_speed);
     t->current_speed = cpu_to_le16(type4.current_speed);
-    t->status = 0x41; /* Socket populated, CPU enabled */
+    t->status = 0x41;            /* Socket populated, CPU enabled */
     t->processor_upgrade = 0x01; /* Other */
     t->l1_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
     t->l2_cache_handle = cpu_to_le16(0xFFFF); /* N/A */
@@ -733,8 +763,7 @@ static void smbios_build_type_4_table(MachineState *ms, unsigned instance,
     smbios_type4_count++;
 }
 
-static void smbios_build_type_8_table(void)
-{
+static void smbios_build_type_8_table(void) {
     unsigned instance = 0;
     struct type8_instance *t8;
 
@@ -753,8 +782,7 @@ static void smbios_build_type_8_table(void)
     }
 }
 
-static void smbios_build_type_9_table(Error **errp)
-{
+static void smbios_build_type_9_table(Error **errp) {
     unsigned instance = 0;
     struct type9_instance *t9;
 
@@ -774,8 +802,7 @@ static void smbios_build_type_9_table(Error **errp)
             PCIDevice *pdev = NULL;
             int rc = pci_qdev_find_device(t9->pcidev, &pdev);
             if (rc != 0) {
-                error_setg(errp,
-                           "No PCI device %s for SMBIOS type 9 entry %s",
+                error_setg(errp, "No PCI device %s for SMBIOS type 9 entry %s",
                            t9->pcidev, t9->slot_designation);
                 return;
             }
@@ -812,8 +839,7 @@ static void smbios_build_type_9_table(Error **errp)
     }
 }
 
-static void smbios_build_type_11_table(void)
-{
+static void smbios_build_type_11_table(void) {
     char count_str[128];
     size_t i;
 
@@ -837,14 +863,13 @@ static void smbios_build_type_11_table(void)
 
 #define MAX_T16_STD_SZ 0x80000000 /* 2T in Kilobytes */
 
-static void smbios_build_type_16_table(unsigned dimm_cnt)
-{
+static void smbios_build_type_16_table(unsigned dimm_cnt) {
     uint64_t size_kb;
 
     SMBIOS_BUILD_TABLE_PRE(16, T16_BASE, true); /* required */
 
-    t->location = 0x01; /* Other */
-    t->use = 0x03; /* System memory */
+    t->location = 0x01;         /* Other */
+    t->use = 0x03;              /* System memory */
     t->error_correction = 0x06; /* Multi-bit ECC (for Microsoft, per SeaBIOS) */
     size_kb = QEMU_ALIGN_UP(current_machine->ram_size, KiB) / KiB;
     if (size_kb < MAX_T16_STD_SZ) {
@@ -860,11 +885,10 @@ static void smbios_build_type_16_table(unsigned dimm_cnt)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-#define MAX_T17_STD_SZ 0x7FFF /* (32G - 1M), in Megabytes */
+#define MAX_T17_STD_SZ 0x7FFF     /* (32G - 1M), in Megabytes */
 #define MAX_T17_EXT_SZ 0x80000000 /* 2P, in Megabytes */
 
-static void smbios_build_type_17_table(unsigned instance, uint64_t size)
-{
+static void smbios_build_type_17_table(unsigned instance, uint64_t size) {
     char loc_str[128];
     uint64_t size_mb;
 
@@ -872,8 +896,8 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
 
     t->physical_memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
     t->memory_error_information_handle = cpu_to_le16(0xFFFE); /* Not provided */
-    t->total_width = cpu_to_le16(0xFFFF); /* Unknown */
-    t->data_width = cpu_to_le16(0xFFFF); /* Unknown */
+    t->total_width = cpu_to_le16(0xFFFF);                     /* Unknown */
+    t->data_width = cpu_to_le16(0xFFFF);                      /* Unknown */
     size_mb = QEMU_ALIGN_UP(size, MiB) / MiB;
     if (size_mb < MAX_T17_STD_SZ) {
         t->size = cpu_to_le16(size_mb);
@@ -884,29 +908,28 @@ static void smbios_build_type_17_table(unsigned instance, uint64_t size)
         t->extended_size = cpu_to_le32(size_mb);
     }
     t->form_factor = 0x09; /* DIMM */
-    t->device_set = 0; /* Not in a set */
+    t->device_set = 0;     /* Not in a set */
     snprintf(loc_str, sizeof(loc_str), "%s %d", type17.loc_pfx, instance);
     SMBIOS_TABLE_SET_STR(17, device_locator_str, loc_str);
     SMBIOS_TABLE_SET_STR(17, bank_locator_str, type17.bank);
-    t->memory_type = 0x07; /* RAM */
+    t->memory_type = 0x07;              /* RAM */
     t->type_detail = cpu_to_le16(0x02); /* Other */
     t->speed = cpu_to_le16(type17.speed);
     SMBIOS_TABLE_SET_STR(17, manufacturer_str, type17.manufacturer);
     SMBIOS_TABLE_SET_STR(17, serial_number_str, type17.serial);
     SMBIOS_TABLE_SET_STR(17, asset_tag_number_str, type17.asset);
     SMBIOS_TABLE_SET_STR(17, part_number_str, type17.part);
-    t->attributes = 0; /* Unknown */
-    t->configured_clock_speed = t->speed; /* reuse value for max speed */
-    t->minimum_voltage = cpu_to_le16(0); /* Unknown */
-    t->maximum_voltage = cpu_to_le16(0); /* Unknown */
+    t->attributes = 0;                      /* Unknown */
+    t->configured_clock_speed = t->speed;   /* reuse value for max speed */
+    t->minimum_voltage = cpu_to_le16(0);    /* Unknown */
+    t->maximum_voltage = cpu_to_le16(0);    /* Unknown */
     t->configured_voltage = cpu_to_le16(0); /* Unknown */
 
     SMBIOS_BUILD_TABLE_POST;
 }
 
 static void smbios_build_type_19_table(unsigned instance, unsigned offset,
-                                       uint64_t start, uint64_t size)
-{
+                                       uint64_t start, uint64_t size) {
     uint64_t end, start_kb, end_kb;
 
     SMBIOS_BUILD_TABLE_PRE(19, T19_BASE + offset + instance,
@@ -919,21 +942,59 @@ static void smbios_build_type_19_table(unsigned instance, unsigned offset,
     if (start_kb < UINT32_MAX && end_kb < UINT32_MAX) {
         t->starting_address = cpu_to_le32(start_kb);
         t->ending_address = cpu_to_le32(end_kb);
-        t->extended_starting_address =
-            t->extended_ending_address = cpu_to_le64(0);
+        t->extended_starting_address = t->extended_ending_address =
+            cpu_to_le64(0);
     } else {
         t->starting_address = t->ending_address = cpu_to_le32(UINT32_MAX);
         t->extended_starting_address = cpu_to_le64(start);
         t->extended_ending_address = cpu_to_le64(end);
     }
     t->memory_array_handle = cpu_to_le16(0x1000); /* Type 16 above */
-    t->partition_width = 1; /* One device per row */
+    t->partition_width = 1;                       /* One device per row */
+
+    SMBIOS_BUILD_TABLE_POST;
+}
+
+static void smbios_build_type_27_table(void) {
+    SMBIOS_BUILD_TABLE_PRE(27, T27_BASE, true); /* required */
+    t->temperature_probe_handler =
+        0xFFFF; // no thermal probe (for now at least)
+    t->device_type_and_status =
+        0b01100011;            // Means that it's a fan and it's doing well
+    t->cooling_unit_group = 0; // we don't have those
+    t->oem_defined = 0;
+    t->nominal_speed = 200;
+    SMBIOS_TABLE_SET_STR(27, description, type27.description);
+    SMBIOS_BUILD_TABLE_POST;
+}
+
+static void smbios_build_type_28_table(void) {
+    SMBIOS_BUILD_TABLE_PRE(28, T28_BASE, true); /* required */
+    t->location_and_status = 0b01100011; // it's on the CPU and it's doing well
+    t->maximum_value = 1270;             // in 1/10 °C
+    t->minimum_value = -1270;            // in 1/10 °C
+    t->resolution = 1000;                // in 1/1000 °C
+    t->tolerance = 0x8000;               // unknown
+    t->accuracy = 0x8000;                // unknown
+    t->nominal_value = 100;              // in 1/10 °C
+    SMBIOS_TABLE_SET_STR(28, description, type28.description);
+    SMBIOS_BUILD_TABLE_POST;
+}
 
+static void smbios_build_type_29_table(void) {
+    SMBIOS_BUILD_TABLE_PRE(29, T29_BASE, true); /* required */
+    t->location_and_status = 0b01100011; // it's on the CPU and it's doing well
+    t->maximum_value = 0x4000;           // in milliamps
+    t->minimum_value = 0;                // in milliamps
+    t->resolution = 1;                   // in milliamps
+    t->tolerance = 0x8000;               // unknown
+    t->accuracy = 0x8000;                // unknown
+    t->nominal_value = 0x8000;           // unknown
+    SMBIOS_TABLE_SET_STR(29, description, type29.description);
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_32_table(void)
-{
+static void smbios_build_type_32_table(void) {
     SMBIOS_BUILD_TABLE_PRE(32, T32_BASE, true); /* required */
 
     memset(t->reserved, 0, 6);
@@ -942,8 +1003,7 @@ static void smbios_build_type_32_table(void)
     SMBIOS_BUILD_TABLE_POST;
 }
 
-static void smbios_build_type_41_table(Error **errp)
-{
+static void smbios_build_type_41_table(Error **errp) {
     unsigned instance = 0;
     struct type41_instance *t41;
 
@@ -961,8 +1021,7 @@ static void smbios_build_type_41_table(Error **errp)
             PCIDevice *pdev = NULL;
             int rc = pci_qdev_find_device(t41->pcidev, &pdev);
             if (rc != 0) {
-                error_setg(errp,
-                           "No PCI device %s for SMBIOS type 41 entry %s",
+                error_setg(errp, "No PCI device %s for SMBIOS type 41 entry %s",
                            t41->pcidev, t41->designation);
                 return;
             }
@@ -989,33 +1048,29 @@ static void smbios_build_type_41_table(Error **errp)
     }
 }
 
-static void smbios_build_type_127_table(void)
-{
+static void smbios_build_type_127_table(void) {
     SMBIOS_BUILD_TABLE_PRE(127, T127_BASE, true); /* required */
     SMBIOS_BUILD_TABLE_POST;
 }
 
-void smbios_set_cpuid(uint32_t version, uint32_t features)
-{
+void smbios_set_cpuid(uint32_t version, uint32_t features) {
     smbios_cpuid_version = version;
     smbios_cpuid_features = features;
 }
 
-#define SMBIOS_SET_DEFAULT(field, value)                                  \
-    if (!field) {                                                         \
-        field = value;                                                    \
+#define SMBIOS_SET_DEFAULT(field, value)                                       \
+    if (!field) {                                                              \
+        field = value;                                                         \
     }
 
-void smbios_set_default_processor_family(uint16_t processor_family)
-{
+void smbios_set_default_processor_family(uint16_t processor_family) {
     if (type4.processor_family <= 0x01) {
         type4.processor_family = processor_family;
     }
 }
 
 void smbios_set_defaults(const char *manufacturer, const char *product,
-                         const char *version)
-{
+                         const char *version) {
     smbios_have_defaults = true;
 
     SMBIOS_SET_DEFAULT(smbios_type1.manufacturer, manufacturer);
@@ -1031,10 +1086,13 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
     SMBIOS_SET_DEFAULT(type4.version, version);
     SMBIOS_SET_DEFAULT(type17.loc_pfx, "DIMM");
     SMBIOS_SET_DEFAULT(type17.manufacturer, manufacturer);
+
+    SMBIOS_SET_DEFAULT(type27.description, "FAN0");
+    SMBIOS_SET_DEFAULT(type28.description, "TPROBE0");
+    SMBIOS_SET_DEFAULT(type29.description, "VPROBE0");
 }
 
-static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
-{
+static void smbios_entry_point_setup(SmbiosEntryPointType ep_type) {
     switch (ep_type) {
     case SMBIOS_ENTRY_POINT_TYPE_32:
         memcpy(ep.ep21.anchor_string, "_SM_", 4);
@@ -1084,14 +1142,12 @@ static void smbios_entry_point_setup(SmbiosEntryPointType ep_type)
     }
 }
 
-static bool smbios_get_tables_ep(MachineState *ms,
-                       SmbiosEntryPointType ep_type,
-                       const struct smbios_phys_mem_area *mem_array,
-                       const unsigned int mem_array_size,
-                       uint8_t **tables, size_t *tables_len,
-                       uint8_t **anchor, size_t *anchor_len,
-                       Error **errp)
-{
+static bool smbios_get_tables_ep(MachineState *ms, SmbiosEntryPointType ep_type,
+                                 const struct smbios_phys_mem_area *mem_array,
+                                 const unsigned int mem_array_size,
+                                 uint8_t **tables, size_t *tables_len,
+                                 uint8_t **anchor, size_t *anchor_len,
+                                 Error **errp) {
     unsigned i, dimm_cnt, offset;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
     ERRP_GUARD();
@@ -1124,8 +1180,11 @@ static bool smbios_get_tables_ep(MachineState *ms,
     smbios_build_type_9_table(errp);
     smbios_build_type_11_table();
 
-#define GET_DIMM_SZ ((i < dimm_cnt - 1) ? mc->smbios_memory_device_size \
-    : ((current_machine->ram_size - 1) % mc->smbios_memory_device_size) + 1)
+#define GET_DIMM_SZ                                                            \
+    ((i < dimm_cnt - 1)                                                        \
+         ? mc->smbios_memory_device_size                                       \
+         : ((current_machine->ram_size - 1) % mc->smbios_memory_device_size) + \
+               1)
 
     dimm_cnt = QEMU_ALIGN_UP(current_machine->ram_size,
                              mc->smbios_memory_device_size) /
@@ -1138,8 +1197,9 @@ static bool smbios_get_tables_ep(MachineState *ms,
      * memory and DIMM like chunks of 16 GiB, the default space between
      * the two tables (T19_BASE - T17_BASE = 512) is not enough.
      */
-    offset = (dimm_cnt > (T19_BASE - T17_BASE)) ? \
-             dimm_cnt - (T19_BASE - T17_BASE) : 0;
+    offset = (dimm_cnt > (T19_BASE - T17_BASE))
+                 ? dimm_cnt - (T19_BASE - T17_BASE)
+                 : 0;
 
     smbios_build_type_16_table(dimm_cnt);
 
@@ -1158,6 +1218,10 @@ static bool smbios_get_tables_ep(MachineState *ms,
      */
     assert((mem_array_size + offset) < (T32_BASE - T19_BASE));
 
+    smbios_build_type_27_table();
+    smbios_build_type_28_table();
+    smbios_build_type_29_table();
+
     smbios_build_type_32_table();
     smbios_build_type_38_table();
     smbios_build_type_41_table(errp);
@@ -1191,14 +1255,11 @@ err_exit:
     return false;
 }
 
-void smbios_get_tables(MachineState *ms,
-                       SmbiosEntryPointType ep_type,
+void smbios_get_tables(MachineState *ms, SmbiosEntryPointType ep_type,
                        const struct smbios_phys_mem_area *mem_array,
-                       const unsigned int mem_array_size,
-                       uint8_t **tables, size_t *tables_len,
-                       uint8_t **anchor, size_t *anchor_len,
-                       Error **errp)
-{
+                       const unsigned int mem_array_size, uint8_t **tables,
+                       size_t *tables_len, uint8_t **anchor, size_t *anchor_len,
+                       Error **errp) {
     Error *local_err = NULL;
     bool is_valid;
     ERRP_GUARD();
@@ -1206,11 +1267,9 @@ void smbios_get_tables(MachineState *ms,
     switch (ep_type) {
     case SMBIOS_ENTRY_POINT_TYPE_AUTO:
     case SMBIOS_ENTRY_POINT_TYPE_32:
-        is_valid = smbios_get_tables_ep(ms, SMBIOS_ENTRY_POINT_TYPE_32,
-                                        mem_array, mem_array_size,
-                                        tables, tables_len,
-                                        anchor, anchor_len,
-                                        &local_err);
+        is_valid = smbios_get_tables_ep(
+            ms, SMBIOS_ENTRY_POINT_TYPE_32, mem_array, mem_array_size, tables,
+            tables_len, anchor, anchor_len, &local_err);
         if (is_valid || ep_type != SMBIOS_ENTRY_POINT_TYPE_AUTO) {
             break;
         }
@@ -1222,11 +1281,9 @@ void smbios_get_tables(MachineState *ms,
     case SMBIOS_ENTRY_POINT_TYPE_64:
         error_free(local_err);
         local_err = NULL;
-        is_valid = smbios_get_tables_ep(ms, SMBIOS_ENTRY_POINT_TYPE_64,
-                                        mem_array, mem_array_size,
-                                        tables, tables_len,
-                                        anchor, anchor_len,
-                                        &local_err);
+        is_valid = smbios_get_tables_ep(
+            ms, SMBIOS_ENTRY_POINT_TYPE_64, mem_array, mem_array_size, tables,
+            tables_len, anchor, anchor_len, &local_err);
         break;
     default:
         abort();
@@ -1236,8 +1293,7 @@ void smbios_get_tables(MachineState *ms,
     }
 }
 
-static void save_opt(const char **dest, QemuOpts *opts, const char *name)
-{
+static void save_opt(const char **dest, QemuOpts *opts, const char *name) {
     const char *val = qemu_opt_get(opts, name);
 
     if (val) {
@@ -1245,16 +1301,13 @@ static void save_opt(const char **dest, QemuOpts *opts, const char *name)
     }
 }
 
-
 struct opt_list {
     size_t *ndest;
     char ***dest;
 };
 
-static int save_opt_one(void *opaque,
-                        const char *name, const char *value,
-                        Error **errp)
-{
+static int save_opt_one(void *opaque, const char *name, const char *value,
+                        Error **errp) {
     struct opt_list *opt = opaque;
 
     if (g_str_equal(name, "path")) {
@@ -1272,8 +1325,8 @@ static int save_opt_one(void *opaque,
                 break;
             }
             if (ret < 0) {
-                error_setg(errp, "Unable to read from %s: %s",
-                           value, strerror(errno));
+                error_setg(errp, "Unable to read from %s: %s", value,
+                           strerror(errno));
                 qemu_close(fd);
                 return -1;
             }
@@ -1288,10 +1341,10 @@ static int save_opt_one(void *opaque,
         qemu_close(fd);
 
         *opt->dest = g_renew(char *, *opt->dest, (*opt->ndest) + 1);
-        (*opt->dest)[*opt->ndest] = (char *)g_byte_array_free(data,  FALSE);
+        (*opt->dest)[*opt->ndest] = (char *)g_byte_array_free(data, FALSE);
         (*opt->ndest)++;
         data = NULL;
-   } else if (g_str_equal(name, "value")) {
+    } else if (g_str_equal(name, "value")) {
         *opt->dest = g_renew(char *, *opt->dest, (*opt->ndest) + 1);
         (*opt->dest)[*opt->ndest] = g_strdup(value);
         (*opt->ndest)++;
@@ -1304,10 +1357,10 @@ static int save_opt_one(void *opaque,
 }
 
 static bool save_opt_list(size_t *ndest, char ***dest, QemuOpts *opts,
-                          Error **errp)
-{
+                          Error **errp) {
     struct opt_list opt = {
-        ndest, dest,
+        ndest,
+        dest,
     };
     if (!qemu_opt_foreach(opts, save_opt_one, &opt, errp)) {
         return false;
@@ -1315,8 +1368,7 @@ static bool save_opt_list(size_t *ndest, char ***dest, QemuOpts *opts,
     return true;
 }
 
-void smbios_entry_add(QemuOpts *opts, Error **errp)
-{
+void smbios_entry_add(QemuOpts *opts, Error **errp) {
     const char *val;
 
     val = qemu_opt_get(opts, "file");
@@ -1340,8 +1392,7 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
          *  will be inserted by the BIOS).
          */
         usr_blobs = g_realloc(usr_blobs, usr_blobs_len + size);
-        header = (struct smbios_structure_header *)(usr_blobs +
-                                                    usr_blobs_len);
+        header = (struct smbios_structure_header *)(usr_blobs + usr_blobs_len);
 
         if (load_image_size(val, (uint8_t *)header, size) != size) {
             error_setg(errp, "Failed to load SMBIOS file %s", val);
@@ -1350,9 +1401,10 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
 
         if (header->type <= SMBIOS_MAX_TYPE) {
             if (test_bit(header->type, smbios_have_fields_bitmap)) {
-                error_setg(errp,
-                           "can't load type %d struct, fields already specified!",
-                           header->type);
+                error_setg(
+                    errp,
+                    "can't load type %d struct, fields already specified!",
+                    header->type);
                 return;
             }
             set_bit(header->type, smbios_have_binfile_bitmap);
@@ -1458,9 +1510,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
                 return;
             }
             save_opt(&type4.sock_pfx, opts, "sock_pfx");
-            type4.processor_family = qemu_opt_get_number(opts,
-                                                         "processor-family",
-                                                         0x01 /* Other */);
+            type4.processor_family =
+                qemu_opt_get_number(opts, "processor-family", 0x01 /* Other */);
             save_opt(&type4.manufacturer, opts, "manufacturer");
             save_opt(&type4.version, opts, "version");
             save_opt(&type4.serial, opts, "serial");
@@ -1468,10 +1519,10 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             save_opt(&type4.part, opts, "part");
             /* If the value is 0, it will take the value from the CPU model. */
             type4.processor_id = qemu_opt_get_number(opts, "processor-id", 0);
-            type4.max_speed = qemu_opt_get_number(opts, "max-speed",
-                                                  DEFAULT_CPU_SPEED);
-            type4.current_speed = qemu_opt_get_number(opts, "current-speed",
-                                                      DEFAULT_CPU_SPEED);
+            type4.max_speed =
+                qemu_opt_get_number(opts, "max-speed", DEFAULT_CPU_SPEED);
+            type4.current_speed =
+                qemu_opt_get_number(opts, "current-speed", DEFAULT_CPU_SPEED);
             if (type4.max_speed > UINT16_MAX ||
                 type4.current_speed > UINT16_MAX) {
                 error_setg(errp, "SMBIOS CPU speed is too large (> %d)",
@@ -1486,8 +1537,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             t8_i = g_new0(struct type8_instance, 1);
             save_opt(&t8_i->internal_reference, opts, "internal_reference");
             save_opt(&t8_i->external_reference, opts, "external_reference");
-            t8_i->connector_type = qemu_opt_get_number(opts,
-                                                       "connector_type", 0);
+            t8_i->connector_type =
+                qemu_opt_get_number(opts, "connector_type", 0);
             t8_i->port_type = qemu_opt_get_number(opts, "port_type", 0);
             QTAILQ_INSERT_TAIL(&type8, t8_i, next);
             return;
@@ -1541,10 +1592,11 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             }
             t41_i = g_new0(struct type41_instance, 1);
             save_opt(&t41_i->designation, opts, "designation");
-            t41_i->kind = qapi_enum_parse(&type41_kind_lookup,
-                                          qemu_opt_get(opts, "kind"),
-                                          0, &local_err) + 1;
-            t41_i->kind |= 0x80;     /* enabled */
+            t41_i->kind =
+                qapi_enum_parse(&type41_kind_lookup, qemu_opt_get(opts, "kind"),
+                                0, &local_err) +
+                1;
+            t41_i->kind |= 0x80; /* enabled */
             if (local_err != NULL) {
                 error_propagate(errp, local_err);
                 g_free(t41_i);
diff --git a/include/hw/firmware/smbios.h b/include/hw/firmware/smbios.h
index f066ab7262..e7f68f05c6 100644
--- a/include/hw/firmware/smbios.h
+++ b/include/hw/firmware/smbios.h
@@ -37,8 +37,8 @@ extern smbios_type1_t smbios_type1;
 extern DECLARE_BITMAP(smbios_have_binfile_bitmap, SMBIOS_MAX_TYPE + 1);
 extern DECLARE_BITMAP(smbios_have_fields_bitmap, SMBIOS_MAX_TYPE + 1);
 
-#define offsetofend(TYPE, MEMBER) \
-       (offsetof(TYPE, MEMBER) + sizeof_field(TYPE, MEMBER))
+#define offsetofend(TYPE, MEMBER)                                              \
+    (offsetof(TYPE, MEMBER) + sizeof_field(TYPE, MEMBER))
 
 /* memory area description, used by type 19 table */
 struct smbios_phys_mem_area {
@@ -215,8 +215,8 @@ struct smbios_type_4 {
 } QEMU_PACKED;
 
 typedef enum smbios_type_4_len_ver {
-    SMBIOS_TYPE_4_LEN_V28 = offsetofend(struct smbios_type_4,
-                                        processor_family2),
+    SMBIOS_TYPE_4_LEN_V28 =
+        offsetofend(struct smbios_type_4, processor_family2),
     SMBIOS_TYPE_4_LEN_V30 = offsetofend(struct smbios_type_4, thread_count2),
 } smbios_type_4_len_ver;
 
@@ -303,6 +303,45 @@ struct smbios_type_19 {
     uint64_t extended_ending_address;
 } QEMU_PACKED;
 
+/* SMBIOS type 27 - Cooling Device */
+struct smbios_type_27 {
+    struct smbios_structure_header header;
+    uint16_t temperature_probe_handler;
+    uint8_t device_type_and_status;
+    uint8_t cooling_unit_group;
+    uint32_t oem_defined;
+    uint16_t nominal_speed;
+    uint8_t description;
+} QEMU_PACKED;
+
+/* SMBIOS type 28 - Temperature Probe */
+struct smbios_type_28 {
+    struct smbios_structure_header header;
+    uint8_t description;
+    uint8_t location_and_status;
+    uint16_t maximum_value;
+    uint16_t minimum_value;
+    uint16_t resolution;
+    uint16_t tolerance;
+    uint16_t accuracy;
+    uint32_t oem_defined;
+    uint16_t nominal_value;
+} QEMU_PACKED;
+
+/* SMBIOS type 29 - Electrical Current Probe */
+struct smbios_type_29 {
+    struct smbios_structure_header header;
+    uint8_t description;
+    uint8_t location_and_status;
+    uint16_t maximum_value;
+    uint16_t minimum_value;
+    uint16_t resolution;
+    uint16_t tolerance;
+    uint16_t accuracy;
+    uint32_t oem_defined;
+    uint16_t nominal_value;
+} QEMU_PACKED;
+
 /* SMBIOS type 32 - System Boot Information */
 struct smbios_type_32 {
     struct smbios_structure_header header;
@@ -334,11 +373,9 @@ void smbios_set_defaults(const char *manufacturer, const char *product,
                          const char *version);
 void smbios_set_default_processor_family(uint16_t processor_family);
 uint8_t *smbios_get_table_legacy(size_t *length, Error **errp);
-void smbios_get_tables(MachineState *ms,
-                       SmbiosEntryPointType ep_type,
+void smbios_get_tables(MachineState *ms, SmbiosEntryPointType ep_type,
                        const struct smbios_phys_mem_area *mem_array,
-                       const unsigned int mem_array_size,
-                       uint8_t **tables, size_t *tables_len,
-                       uint8_t **anchor, size_t *anchor_len,
+                       const unsigned int mem_array_size, uint8_t **tables,
+                       size_t *tables_len, uint8_t **anchor, size_t *anchor_len,
                        Error **errp);
 #endif /* QEMU_SMBIOS_H */
